<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>1.14.&nbsp;Metadata import</title><link rel="stylesheet" type="text/css" href="resources/css/docbook_bsd.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="dhis2_developer_manual.html" title="DHIS2 Developer Manual"><link rel="up" href="ch01.html" title="Chapter&nbsp;1.&nbsp;Web API"><link rel="prev" href="ch01s13.html" title="1.13.&nbsp;Metadata export"><link rel="next" href="ch01s15.html" title="1.15.&nbsp;Metadata versioning"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1.14.&nbsp;Metadata import</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch01s13.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;1.&nbsp;Web API</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch01s15.html">Next</a></td></tr></table><hr></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2629"></a>1.14.&nbsp;Metadata import</h2></div></div></div><p>This section explain the new metadata importer available from DHIS2.23, the metatada API
      is available at <span class="italic">/api/23/metadata</span> and <span class="italic">/api/24/metadata</span>endpoints, both XML and JSON is supported in this
      importer.</p><p>The importer allows you to import metadata exported with the new exporter, the different
      parameters are listed down below.</p><div class="table"><a name="d0e2642"></a><p class="title"><b>Table&nbsp;1.21.&nbsp;Import Parameter</b></p><div class="table-contents"><table class="table" summary="Import Parameter" border="1"><colgroup><col class="c1"><col class="c2"><col class="c3"></colgroup><thead><tr><th>Name</th><th>Options (first is default)</th><th>Description</th></tr></thead><tbody><tr><td>importMode</td><td>COMMIT, VALIDATE</td><td>Sets overall import mode, decides whether or not to only <span class="bold"><strong>VALIDATE</strong></span> or also <span class="bold"><strong>COMMIT</strong></span> the metadata,
              this have similar functionality as our old dryRun flag.</td></tr><tr><td>identifier</td><td>UID, CODE, AUTO</td><td>Sets the identifier scheme to use for reference matching. <span class="bold"><strong>AUTO</strong></span> means try <span class="bold"><strong>UID</strong></span> first, then
                <span class="bold"><strong>CODE</strong></span>.</td></tr><tr><td>preheatMode</td><td>REFERENCE, ALL, NONE</td><td>Sets the preheater mode, used to signal if preheating should be done for
                <span class="bold"><strong>ALL</strong></span> (as it was before with <span class="italic">preheatCache=true</span>) or do a more intelligent scan of the objects to see
              what to preheat (now the default), setting this to <span class="bold"><strong>NONE</strong></span> is not recommended.</td></tr><tr><td>importStrategy</td><td>CREATE_AND_UPDATE, CREATE, UPDATE, DELETE</td><td>Sets import strategy, <span class="bold"><strong>CREATE_AND_UPDATE</strong></span> will try
              and match on identifier, if it doesn't exist, it will create the object.</td></tr><tr><td>atomicMode</td><td>ALL, NONE</td><td>Sets atomic mode, in the old importer we always did a <span class="italic">best effort</span> import, which means that even if some references did not
              exist, we would still import (i.e. missing data elements on a data element group
              import). Default for new importer is to not allow this, and similar reject any
              validation errors. Setting the <span class="bold"><strong>NONE</strong></span> mode emulated the
              old behavior.</td></tr><tr><td>mergeMode</td><td>MERGE, REPLACE</td><td>Sets the merge mode, when doing updates we have two ways of merging the old
              object with the new one, <span class="bold"><strong>MERGE</strong></span> mode will only
              overwrite the old property if the new one is not-null, for <span class="bold"><strong>REPLACE</strong></span> mode all properties are overwritten regardsless of null or
              not.</td></tr><tr><td>flushMode</td><td>AUTO, OBJECT</td><td>Sets the flush mode, decides when to flush the internal cache, <span class="italic">strongly</span> reommended to keep this to <span class="bold"><strong>AUTO</strong></span> (which is the default). Only use <span class="bold"><strong>OBJECT</strong></span> for debugging purposes, where you are seeing hibernate exceptions
              and want to pinpoint the exact place where the stack happens (hibernate will only
              throw when flushing, so it can be hard to know which object had issues).</td></tr><tr><td>skipSharing</td><td>false, true</td><td>Skip sharing properties, does not merge sharing when doing updates, and does not
              add user group accessses when creating new objects.</td></tr><tr><td>skipValidation</td><td>false, true</td><td>Skip validation for import. <span class="bold"><strong>NOT
              RECOMMENDED</strong></span>.</td></tr></tbody></table></div></div><br class="table-break"></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch01s13.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch01.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch01s15.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">1.13.&nbsp;Metadata export&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="dhis2_developer_manual.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;1.15.&nbsp;Metadata versioning</td></tr></table></div></body></html>